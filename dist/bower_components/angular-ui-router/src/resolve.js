function $Resolve(a,b){var c=1,d=2,e={},f=[],g=e,h=extend(a.when(e),{$$promises:e,$$values:e});this.study=function(e){function i(a,g){if(n[g]!==d){if(m.push(g),n[g]===c)throw m.splice(0,indexOf(m,g)),new Error("Cyclic dependency: "+m.join(" -> "));if(n[g]=c,isString(a))l.push(g,[function(){return b.get(a)}],f);else{var h=b.annotate(a);forEach(h,function(a){a!==g&&e.hasOwnProperty(a)&&i(e[a],a)}),l.push(g,a,h)}m.pop(),n[g]=d}}function j(a){return isObject(a)&&a.then&&a.$$promises}if(!isObject(e))throw new Error("'invocables' must be an object");var k=objectKeys(e||{}),l=[],m=[],n={};return forEach(e,i),e=m=n=null,function(c,d,e){function f(){--r||(s||merge(q,d.$$values),o.$$values=q,o.$$promises=o.$$promises||!0,delete o.$$inheritedValues,n.resolve(q))}function i(a){o.$$failure=a,n.reject(a)}function m(d,g,h){function j(a){l.reject(a),i(a)}function k(){if(!isDefined(o.$$failure))try{l.resolve(b.invoke(g,e,q)),l.promise.then(function(a){q[d]=a,f()},j)}catch(a){j(a)}}var l=a.defer(),m=0;forEach(h,function(a){p.hasOwnProperty(a)&&!c.hasOwnProperty(a)&&(m++,p[a].then(function(b){q[a]=b,--m||k()},j))}),m||k(),p[d]=l.promise}if(j(c)&&void 0===e&&(e=d,d=c,c=null),c){if(!isObject(c))throw new Error("'locals' must be an object")}else c=g;if(d){if(!j(d))throw new Error("'parent' must be a promise returned by $resolve.resolve()")}else d=h;var n=a.defer(),o=n.promise,p=o.$$promises={},q=extend({},c),r=1+l.length/3,s=!1;if(isDefined(d.$$failure))return i(d.$$failure),o;d.$$inheritedValues&&merge(q,omit(d.$$inheritedValues,k)),extend(p,d.$$promises),d.$$values?(s=merge(q,omit(d.$$values,k)),o.$$inheritedValues=omit(d.$$values,k),f()):(d.$$inheritedValues&&(o.$$inheritedValues=omit(d.$$inheritedValues,k)),d.then(f,i));for(var t=0,u=l.length;u>t;t+=3)c.hasOwnProperty(l[t])?f():m(l[t],l[t+1],l[t+2]);return o}},this.resolve=function(a,b,c,d){return this.study(a)(b,c,d)}}$Resolve.$inject=["$q","$injector"],angular.module("ui.router.util").service("$resolve",$Resolve);